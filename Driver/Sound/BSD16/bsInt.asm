COMMENT @/********************************************************

	Copyright (c) Dirk Lausecker -- All Rights Reserved

PROJECT:	BestSound

DATEI:		bsint.asm

AUTOR:		Dirk Lausecker

REVISION HISTORY:
	Name	Datum		Beschreibung
	----	-----		------------
	DL	08.08.98	Init
        DL	22.08.2000	Translation for ND


*****************************************************************/@

idata   segment

;
;  For whatever reason, the FM chip on the sound blaster cards have
;  a register set that is read only.  That means, if we wish to change
;  a single bit (like set the note-off without changing the freqency or
;  octive) we must keep our own copy of the registers.
;
;  We do this by keeping a duplicate copy of the registers in idata.
;
        ;
        ;  We never want to program an illegal register
        ;       value, and we don't want to spend the
        ;       ~30 usec programming a register if
        ;       don't have to.  So, we keep two maps
        ;       of the register set, one containing
        ;       the last know value, and the other
        ;       containing a mask of which are legal
        ;       to change, and which are not....

        ourFMRegisterMap        FMRegisterMap
        ourValidFMRegisterMap   FMRegisterMap

idata   ends

ResidentCode            segment resource

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SBDDACEndOfDMATransfer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:       Handle EOD (End Of DMA) interrupt

CALLED BY:      INTERRUPT
PASS:           nothing
RETURN:         nothing
DESTROYED:      nothing at all!
SIDE EFFECTS:
		Sets up remainder of DMA transfer if pending.


PSEUDO CODE/STRATEGY:
		Remember, this gets called at the end of the
		DMA transfer.  Most likely, we do nothing, but
		if the transfer fell across a page boundry, or
		it was from a stream, there will very likely
		be another transfer waiting.  Thus, we must
		re-program everything in under a sample.

                For 4kHz, we have 250 usec.
                For 22kHz, we have under 50usec.
                For 44kHz, we have only 25usec.

                On an IBM PC, that means we have 100-200 cycles
                before we get a pop.  Blech.

                On a base 8Mhz AT, we get, 200-400 cycles.  Blech.

REVISION HISTORY:
        Name    Date            Description
        ----    ----            -----------
        TS      10/26/92        Initial version

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@
bumInterrupt            label near
        ;
        ;  We recieved a fake int 7.  pop ax and return from the interrupt.
        pop     ax
        iret


SBDDACEndOfDMATransferInt7      proc    far
        ;
        ;  The SoundBlaster cards can be programmed to interrupt at
        ;  level 7 at the end of a DMA transfer.  As interrupt 7 is
        ;  also the default interrupt, we might need to check that the
        ;  interrupt we recieve is really the interrupt generated by
        ;  the board, and not just a "fake" interrupt.
        push    ax      ; save trashed register

        mov     al, IC_READ_ISR                 ; read interrupt status reg.
        out     IC1_CMDPORT, al                 ; instruct chip
        jmp     $+2

        in      al, IC1_CMDPORT                 ; read status register

        test    al, (1 shl 7)                   ; is bit 7 set?
        jz      bumInterrupt                    ; if not, we're done

        pop     ax      ; restore trashed register
        .fall_thru
SBDDACEndOfDMATransferInt7      endp

;---------------------------------
;	ENTRY
;---------------------------------

SBDDACEndOfDMATransfer          proc    far
        pushf
	INT_OFF

;-------------------------
; Prepare "private" Stack
;-------------------------
	mov	cs:[oldSS],ss
	mov	cs:[oldSP],sp
	mov	ss,cs:[bsisrSS]
	mov	sp,cs:[bsisrSP]

        uses    ax, bx,cx, dx, ds, si, es, si, bp
        .enter

        call    SysEnterInterrupt

        cld

        mov     ax, segment dgroup              ; ax <- dgroup of driver
        mov     ds, ax                          ; es <- dgroup of driver

        call	BSECTest


ackInterrupt::
        ;
        ;  Not only must the interrupt controller be told
        ;       of the completion of the interrupt, but so
        ;       must the DSP itself.  This is done
        ;       By reading from the data available port once.
        ;

	mov     dx, ds:[readStatusPort]         ; dx = 2xeh

	mov	al,ds:[bsRecBits]
        cmp	al,16				; 16 Bit DMA ?
        jnz	ack_8				; no
;
; 16 Bit Interrupt acknowledge to Port 2xfh
;
	inc	dx

ack_8:
	in      al, dx

        ;
        ;  Now, there is nothing that is keeping us from
        ;       sending an EOI right now.  But before we
        ;       do, we want to "exit" this interrupt

        ;  On any computer, with any setting, anywhere,
        ;       we send an EOI to the interrupt chip
        ;       on the PC.  So, why not do it now.


        mov     al, IC_GENEOI
        out     IC1_CMDPORT, al                 ; acknowledge PC chip

;---------------------------------
;    Handling for AutoInit
;---------------------------------
;        WARNING	BS_ISR

        mov	al,ds:[bsStatus]
	cmp	al,BSREC_STATE_RUN		; Recording ?
        jnz	no_rec
        call	BSRECISR			; yes
        jmp	short yes_rec
no_rec:
	cmp	al,BSNW_PLAY_RUN		; NewWave-Play ?
        jnz	no_nw
        call	BSNWISR				; yes
        jmp	short yes_rec

no_nw:
	call	BSDACISR			; Play

yes_rec:
        call    SysExitInterrupt

        .leave

;------------------------
; Restore Stack
;------------------------
	mov	ss,cs:[oldSS]
	mov	sp,cs:[oldSP]

	popf
SafePopf        label   far
        iret

;---------------------
; Stack Var.
;---------------------
oldSS	word	0			; Stacksegment
oldSP	word	0			; Stackpointer
bsisrSS	word	0
bsisrSP	word	0


SBDDACEndOfDMATransfer  endp


COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		BSCreateStack
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

BSCreateStack proc    far
	uses	ax, bx, cx
	.enter

;-----------------------
;	Allocate
;-----------------------
	mov	ax,1000			; size
	mov	cs:[bsisrSP],ax		; Stackpointer
        mov	cl,mask HF_FIXED	; HeapFlags
        mov	ch,mask HAF_ZERO_INIT	; HeapAllocFlags
	call	MemAlloc
        mov	ds:[stackHandle],bx	; Handle
	mov	cs:[bsisrSS],ax		; Stacksegment

        .leave
	ret

BSCreateStack endp

COMMENT @%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		BSFreeStack
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@

BSFreeStack proc    far
	uses	ax, bx, cx
	.enter

;-----------------------
;
;-----------------------
        mov	bx,ds:[stackHandle]
	tst	bx
	jz	done
	call	MemFree
        clr	ds:[stackHandle]
done:
        .leave
	ret

BSFreeStack endp

ResidentCode    ends

